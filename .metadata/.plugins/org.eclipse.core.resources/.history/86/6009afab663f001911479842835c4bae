package Sorts;

import java.util.Comparator;

public class Client {
	
	private int cutoff = 1;
	private int idCutoff = 15;
	private static final int index = 5;
	private static Comparator<File> forward = File.ALPHABETICAL;
	private static Comparator<File> reverse = File.REVERSE;
	private static Comparator<File> byId = File.BY_ID;
	
	private Shuffle shuffle;
	private SelectionSort selectionSort;
	private InsertionSort insertionSort;
	private ShellSort shellSort;
	private MergeSort mergeSort;
	
	public static void main(String[] args) {
		double watch = System.currentTimeMillis();
		File[] arr = new File[args.length];
		for(int i=0; i<args.length; i++) {
			arr[i] = new File(args[i],index);
		}
		System.out.println("Size: " + arr.length);
		
		Client client = new Client();
		
		//client.print("Shuffle",arr,null);
		client.print("SelectionSort",arr,forward);
		File[] temp = new File[arr.length];
		for(int i=0; i<arr.length; i++)
			temp[i] = arr[i];
		//client.print("InsertionSort",arr,forward);
		//client.print("ShellSort",arr,forward);
		client.print("MergeSort",arr,forward);
		//assert sorted(temp,arr);
		//client.print("MergeBottomUp",arr,reverse);
		
		//client.byId(arr);
		System.out.println("Running Time: " + Double.toString((System.currentTimeMillis() - watch)/1000));
	}
	
	private static boolean sorted(File[] a, File[] b) {
		for(int i=0; i<a.length; i++)
			if(a[i] != b[i])
				return false;
		return true;
	}
	
	public Client() {
		shuffle = new Shuffle();
		selectionSort = new SelectionSort();
		insertionSort = new InsertionSort();
		shellSort = new ShellSort();
		mergeSort = new MergeSort();
	}
	
	private void print(String sort, File[] arr, Comparator<File> comparator) {
		shuffle.shuffle(arr);
		double watch = System.currentTimeMillis();
		switch (sort) {
			case "SelectionSort":
				System.out.println("Shuffled...");
				System.out.println("Selection Sort: ");
				selectionSort.sort(arr,comparator);
				break;
			case "InsertionSort":
				System.out.println("Shuffled...");
				System.out.println("Insertion Sort: ");
				insertionSort.sort(arr,0,arr.length-1,comparator);
				break;
			case "ShellSort":
				System.out.println("Shuffled...");
				System.out.println("Shell Sort: ");
				shellSort.sort(arr,comparator);
				break;
			case "MergeSort":
				System.out.println("Shuffled...");
				System.out.println("Merge Sort: ");
				mergeSort.sort(arr,comparator);
				break;
			case "MergeBottomUp":
				System.out.println("Shuffled...");
				System.out.println("Merge Sort (Bottom-Up): ");
				mergeSort.bottomUp(arr,comparator);
				break;
			case "Shuffle":
				System.out.println("Shuffle: ");
				break;
			default:
				System.out.println("No Such Sort.");
				break;
		}
		watch = (System.currentTimeMillis() - watch)/1000;
		for(int i=0; i<arr.length/cutoff; i++)
			System.out.print(arr[i].get() + " ");
		if(cutoff > 1) System.out.println(" ...");
		else System.out.println("");
		System.out.println(Double.toString(watch));
		System.out.println("");
	}
	
	private void byId(File[] arr) {
		System.out.println("Sorted By ID: ");
		insertionSort.sort(arr,0,arr.length-1,byId);
		assert sortedById(arr,forward);
		
		if(idCutoff > 0) {
			int k = idCutoff;
			for(int i=0; i<arr.length; i++) {
				if(i <= k) {
					System.out.println(Integer.toString(arr[i].getId()) + " " + arr[i].get());
				} else if(arr[i].getId() == index) {
					break;
				} else {
					if(arr[i].getId() < arr[i+1].getId()) {
						k = i + idCutoff;
						System.out.println("...");
					}
				}
			}
		} else {
			for(int i=0; i<arr.length/cutoff; i++)
				System.out.println(Integer.toString(arr[i].getId()) + " " + arr[i].get());
		}
		
		if(cutoff > 1) System.out.println(" ...");
		else System.out.println("");
		System.out.println("");
	}
	
	private boolean sortedById(File[] arr, Comparator<File> c) {
		int k = 0;
		for(int i=0; i<index; i++) {
			for(int j=k; j<arr.length-1; j++) {
				if(arr[j].getId() != arr[j+1].getId()) {
					k=j;
					break;
				}
				else if(c.compare(arr[j], arr[j+1]) > 0)
					return false;
			}
		}
		return true;
	}
}
