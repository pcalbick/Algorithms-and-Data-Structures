import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
	private int[] grid;
	private WeightedQuickUnionUF quickUnion;
	private final int n;
	private int count;
	
	public Percolation(int n) {
		this.n = n;
		grid = new int[n*n];
		quickUnion = new WeightedQuickUnionUF(n*n);
		for(int i = 0; i < grid.length; i++) {
			int col = i%n;
			int row = n*(int)Math.floor((double)i/(double)n);
			open(row,col);
		}
	}
	
	public void open(int row, int col) {
		if (StdRandom.uniform(2) == 1) {
			grid[row + col] = 1;
			if (row - 1 > 0 && isOpen(row - n, col))
				union(row + col, (row - n) + col);
			if (col - 1 > 0 && isOpen(row, col - 1))
				union(row + col, row + (col - 1));
			count++;
		}
	}
	
	public boolean isOpen(int row, int col) {
		if (grid[row + col] == 1)
			return true;
		return false;
	}
	
	public boolean isFull(int row, int col) {
		if (grid[row + col] == 0)
			return true;
		return false;
	}
	
	public int numberOfOpenSites() {
		return count;
	}
	
	public boolean percolates() {
		quickUnion.find()
			return true;
		return false;
	}
	
	private int root(int i) {
		while(id[i] != i) {
			id[i] = id[id[i]];
			i = id[i];
		}
		return i;
	}
	
	private void union(int i, int j) {
		int p = root(i);
		int q = root(j);
		if (p == q)
			return;
		if (sz[p] < sz[q]) {
			id[p] = q;
			sz[q] += sz[p];
		} else {
			id[q] = p;
			sz[p] += sz[q];
		}
	}
}
